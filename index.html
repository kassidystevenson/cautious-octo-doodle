<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Whack-a-Jerry Can!</title>
  <link rel="stylesheet" href="style.css">
  <style>
    /* Quick yellow jerry can style for canvas */
    .milestone {
      color: #fbc02d;
      font-weight: bold;
      margin-top: 10px;
      font-size: 20px;
      min-height: 28px;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <h1>Whack-a-Jerry Can!</h1>
    <div id="score">Score: 0</div>
    <div id="message"></div>
    <div class="milestone" id="milestone"></div>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const messageEl = document.getElementById('message');
    const milestoneEl = document.getElementById('milestone');

    // Game settings
    const MOLE_SIZE = 60;
    const OBSTACLE_SIZE = 55;
    const MOLE_COLOR = "#fbc02d"; // charity: water yellow
    const OBSTACLE_COLOR = "#bdbdbd"; // gray for fake cans
    const MOLE_APPEAR_TIME = 900; // ms
    const OBSTACLE_APPEAR_TIME = 900; // ms
    const MOLE_POPUP_INTERVAL = 650; // ms
    const NUM_HOLES = 6;

    let score = 0;
    let moles = [];
    let obstacles = [];
    let lastMilestone = 0;
    let gameActive = true;

    // Predefined holes (positions)
    const holes = [
      { x: 80, y: 140 },
      { x: 320, y: 140 },
      { x: 80, y: 300 },
      { x: 320, y: 300 },
      { x: 80, y: 460 },
      { x: 320, y: 460 }
    ];

    function drawJerryCan(x, y, size, color) {
      ctx.save();
      // Body
      ctx.beginPath();
      ctx.moveTo(x - size/2 + 8, y - size/2 + 10);
      ctx.lineTo(x + size/2 - 8, y - size/2 + 10);
      ctx.lineTo(x + size/2 - 8, y + size/2 - 10);
      ctx.lineTo(x - size/2 + 8, y + size/2 - 10);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.shadowColor = "#fbc02d88";
      ctx.shadowBlur = 8;
      ctx.fill();

      // Handle
      ctx.beginPath();
      ctx.moveTo(x - size/2 + 12, y - size/2 + 10);
      ctx.lineTo(x - size/2 + 24, y - size/2 - 8);
      ctx.lineTo(x - size/2 + 36, y - size/2 + 10);
      ctx.closePath();
      ctx.fillStyle = "#fffde7";
      ctx.fill();

      // Cap
      ctx.beginPath();
      ctx.arc(x - size/2 + 24, y - size/2 - 8, 5, 0, Math.PI * 2);
      ctx.fillStyle = "#fbc02d";
      ctx.fill();

      // Cross
      ctx.strokeStyle = "#fffde7";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x - size/2 + 16, y - size/2 + 20);
      ctx.lineTo(x + size/2 - 16, y + size/2 - 20);
      ctx.moveTo(x + size/2 - 16, y - size/2 + 20);
      ctx.lineTo(x - size/2 + 16, y + size/2 - 20);
      ctx.stroke();

      ctx.restore();
    }

    function drawObstacle(x, y, size) {
      // Fake can: gray, no cross, different handle
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x - size/2 + 8, y - size/2 + 10);
      ctx.lineTo(x + size/2 - 8, y - size/2 + 10);
      ctx.lineTo(x + size/2 - 8, y + size/2 - 10);
      ctx.lineTo(x - size/2 + 8, y + size/2 - 10);
      ctx.closePath();
      ctx.fillStyle = OBSTACLE_COLOR;
      ctx.shadowColor = "#bdbdbd88";
      ctx.shadowBlur = 8;
      ctx.fill();

      // Handle (different shape)
      ctx.beginPath();
      ctx.arc(x - size/2 + 24, y - size/2 + 10, 8, 0, Math.PI, true);
      ctx.strokeStyle = "#eeeeee";
      ctx.lineWidth = 3;
      ctx.stroke();

      ctx.restore();
    }

    function drawHoles() {
      ctx.save();
      ctx.globalAlpha = 0.13;
      for (let h of holes) {
        ctx.beginPath();
        ctx.ellipse(h.x, h.y + 20, MOLE_SIZE/2, 18, 0, 0, Math.PI * 2);
        ctx.fillStyle = "#795548";
        ctx.fill();
      }
      ctx.restore();
    }

    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawHoles();
      // Draw moles (jerry cans)
      for (let m of moles) {
        drawJerryCan(m.x, m.y, MOLE_SIZE, MOLE_COLOR);
      }
      // Draw obstacles
      for (let o of obstacles) {
        drawObstacle(o.x, o.y, OBSTACLE_SIZE);
      }
    }

    function showMessage(msg) {
      messageEl.textContent = msg;
      setTimeout(() => {
        if (messageEl.textContent === msg) messageEl.textContent = '';
      }, 900);
    }

    function showMilestone(msg) {
      milestoneEl.textContent = msg;
      setTimeout(() => {
        if (milestoneEl.textContent === msg) milestoneEl.textContent = '';
      }, 1800);
    }

    function spawnMole() {
      if (!gameActive) return;
      // Pick a random hole not occupied
      let available = holes.filter(h => !moles.some(m => m.holeIdx === holes.indexOf(h)) && !obstacles.some(o => o.holeIdx === holes.indexOf(h)));
      if (available.length === 0) return;
      let idx = Math.floor(Math.random() * available.length);
      let holeIdx = holes.indexOf(available[idx]);
      let mole = {
        x: holes[holeIdx].x,
        y: holes[holeIdx].y,
        holeIdx: holeIdx,
        timeout: null
      };
      moles.push(mole);
      mole.timeout = setTimeout(() => {
        // Remove mole if not whacked
        moles = moles.filter(m => m !== mole);
      }, MOLE_APPEAR_TIME);
    }

    function spawnObstacle() {
      if (!gameActive) return;
      // 30% chance to spawn an obstacle
      if (Math.random() > 0.3) return;
      let available = holes.filter(h => !moles.some(m => m.holeIdx === holes.indexOf(h)) && !obstacles.some(o => o.holeIdx === holes.indexOf(h)));
      if (available.length === 0) return;
      let idx = Math.floor(Math.random() * available.length);
      let holeIdx = holes.indexOf(available[idx]);
      let obstacle = {
        x: holes[holeIdx].x,
        y: holes[holeIdx].y,
        holeIdx: holeIdx,
        timeout: null
      };
      obstacles.push(obstacle);
      obstacle.timeout = setTimeout(() => {
        obstacles = obstacles.filter(o => o !== obstacle);
      }, OBSTACLE_APPEAR_TIME);
    }

    function checkMilestone() {
      const milestones = [
        { score: 5, msg: "Milestone: 5 cans! Great start!" },
        { score: 10, msg: "Milestone: 10 cans! Keep going!" },
        { score: 20, msg: "Milestone: 20 cans! Amazing!" },
        { score: 30, msg: "Milestone: 30 cans! You're a hero!" }
      ];
      for (let m of milestones) {
        if (score >= m.score && lastMilestone < m.score) {
          showMilestone(m.msg);
          lastMilestone = m.score;
        }
      }
    }

    canvas.addEventListener('click', e => {
      if (!gameActive) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      // Check moles first
      for (let i = moles.length - 1; i >= 0; i--) {
        const m = moles[i];
        const dx = m.x - mouseX;
        const dy = m.y - mouseY;
        if (Math.abs(dx) < MOLE_SIZE/2 && Math.abs(dy) < MOLE_SIZE/2) {
          // Whacked!
          clearTimeout(m.timeout);
          moles.splice(i, 1);
          score += 1;
          scoreEl.textContent = 'Score: ' + score;
          showMessage('Nice whack!');
          checkMilestone();
          return;
        }
      }
      // Check obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        const dx = o.x - mouseX;
        const dy = o.y - mouseY;
        if (Math.abs(dx) < OBSTACLE_SIZE/2 && Math.abs(dy) < OBSTACLE_SIZE/2) {
          // Hit obstacle: penalty
          clearTimeout(o.timeout);
          obstacles.splice(i, 1);
          score = Math.max(0, score - 1);
          scoreEl.textContent = 'Score: ' + score;
          showMessage('Oops! Fake can!');
          return;
        }
      }
    });

    function gameLoop() {
      drawGame();
      if (gameActive) requestAnimationFrame(gameLoop);
    }

    // Fast-paced spawn
    setInterval(spawnMole, MOLE_POPUP_INTERVAL);
    setInterval(spawnObstacle, MOLE_POPUP_INTERVAL);

    // Start game
    gameLoop();
  </script>
</body>
</html>
